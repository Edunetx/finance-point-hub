<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>CBT Practice</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />
  <style>
    body {
      background: #000 url('https://cdn.jsdelivr.net/gh/Julian-Nash/assets@main/tech-background.gif') center/cover no-repeat;
      color: gold;
      font-family: 'Segoe UI', sans-serif;
      margin: 0;
      padding: 0;
    }
    header {
      background-color: rgba(20, 20, 20, 0.95);
      display: flex;
      align-items: center;
      padding: 15px 20px;
      box-shadow: 0 0 10px gold;
      position: sticky;
      top: 0;
      z-index: 1000;
    }
    header h1 {
      font-size: 1.5rem;
      flex-grow: 1;
      text-align: center;
    }
    .back-icon {
      font-size: 1.2rem;
      color: gold;
      cursor: pointer;
    }
    .container {
      max-width: 800px;
      margin: 30px auto;
      background: rgba(20, 20, 20, 0.9);
      padding: 20px;
      border-radius: 10px;
      box-shadow: 0 0 12px gold;
    }
    .question-box {
      margin-bottom: 20px;
    }
    .question-box h2 {
      margin-bottom: 15px;
    }
    .options {
      list-style: none;
      padding: 0;
    }
    .options li {
      background: rgba(255, 215, 0, 0.08);
      margin-bottom: 10px;
      padding: 10px;
      border: 1px solid gold;
      border-radius: 6px;
      cursor: pointer;
    }
    .options li.selected {
      background: gold;
      color: black;
      font-weight: bold;
    }
    .navigation {
      display: flex;
      justify-content: space-between;
      margin-top: 20px;
    }
    .navigation button {
      padding: 10px 20px;
      background-color: gold;
      color: black;
      border: none;
      border-radius: 6px;
      font-weight: bold;
      cursor: pointer;
    }
    .navigation button:disabled {
      background: gray;
      cursor: not-allowed;
    }
    .submit-btn {
      margin-top: 30px;
      background: crimson;
    }
    .timer {
      text-align: right;
      font-size: 1.1rem;
      margin-bottom: 10px;
      font-weight: bold;
    }
    .result-container {
      background-color: #111;
      border: 2px solid gold;
      padding: 20px;
      border-radius: 10px;
      display: none;
      margin-top: 20px;
    }
    .result-container h2 {
      color: gold;
      margin-bottom: 15px;
    }
    const randomIndex = Math.floor(Math.random() * questions.length);
      if (!usedIndexes.includes(randomIndex)) {
        usedIndexes.push(randomIndex);
        shuffled.push(questions[randomIndex]);
      }
    }
    return shuffled;
  }

  function loadQuestion(index) {
    const q = questions[index];
    currentQuestionIndex = index;

    document.getElementById("question-number").textContent = `Question ${index + 1} of ${questions.length}`;
    document.getElementById("question-text").textContent = q.question;

    const optionsDiv = document.getElementById("options");
    optionsDiv.innerHTML = "";

    q.options.forEach((opt, i) => {
      const btn = document.createElement("button");
      btn.textContent = opt;
      btn.onclick = () => selectOption(opt);
      if (userAnswers[index] === opt) {
        btn.classList.add("selected");
      }
      optionsDiv.appendChild(btn);
    });

    document.getElementById("prevBtn").disabled = index === 0;
    document.getElementById("nextBtn").disabled = index === questions.length - 1;
  }

  function selectOption(option) {
    userAnswers[currentQuestionIndex] = option;
    loadQuestion(currentQuestionIndex); // re-render to reflect selection
  }

  document.getElementById("prevBtn").onclick = () => {
    if (currentQuestionIndex > 0) {
      loadQuestion(currentQuestionIndex - 1);
    }
  };

  document.getElementById("nextBtn").onclick = () => {
    if (currentQuestionIndex < questions.length - 1) {
      loadQuestion(currentQuestionIndex + 1);
    }
  };

  document.getElementById("submitBtn").onclick = () => {
    const unanswered = questions.filter((_, i) => !userAnswers[i]);
    if (unanswered.length > 0) {
      if (!confirm("You have unanswered questions. Submit anyway?")) return;
    }
    finishQuiz();
  };

  function finishQuiz() {
    clearInterval(timerInterval);

    const resultContainer = document.getElementById("result");
    const qnaContainer = document.getElementById("qna");
    const scoreDisplay = document.getElementById("scoreDisplay");

    let correctCount = 0;
    let outputHTML = "";

    questions.forEach((q, i) => {
      const userAns = userAnswers[i] || "No Answer";
      const correct = q.answer;
      const isCorrect = userAns === correct;
      if (isCorrect) correctCount++;

      outputHTML += `
        <div class="q-item">
          <p><strong>Q${i + 1}:</strong> ${q.question}</p>
          <p><strong>Your Answer:</strong> ${userAns}</p>
          <p><strong>Correct Answer:</strong> ${correct}</p>
          <hr />
        </div>
      `;
    });

    const percentage = Math.round((correctCount / questions.length) * 100);
    scoreDisplay.textContent = `You scored ${correctCount}/${questions.length} (${percentage}%)`;

    qnaContainer.innerHTML = outputHTML;
    resultContainer.style.display = "block";
    document.querySelector(".quiz").style.display = "none";

    // Store result in Firestore
    const timestamp = new Date();
    const userId = auth.currentUser?.uid;
    if (userId) {
      const resultRef = doc(db, "cbt_scores", userId);
      setDoc(resultRef, {
        userId,
        fullName: auth.currentUser.displayName || "",
        score: correctCount,
        total: questions.length,
        time: timestamp,
      });

      // Save CBT timestamp to restrict reattempts
      const userRef = doc(db, "users", userId);
      setDoc(userRef, { lastCBT: timestamp }, { merge: true });
    }
  }
</script>
                        let questions = [];
    let currentQuestion = 0;
    let userAnswers = {};
    let timerInterval;

    const questionBox = document.getElementById("questionBox");
    const qNumber = document.getElementById("qNumber");
    const optionsBox = document.getElementById("optionsBox");
    const prevBtn = document.getElementById("prevBtn");
    const nextBtn = document.getElementById("nextBtn");
    const submitBtn = document.getElementById("submitBtn");
    const timer = document.getElementById("timer");

    const calculator = document.getElementById("calculator");
    const calcToggle = document.getElementById("calcToggle");
    calcToggle.onclick = () => calculator.style.display = calculator.style.display === "block" ? "none" : "block";

    document.querySelectorAll(".calculator button").forEach(btn => {
      btn.onclick = () => {
        const display = document.getElementById("display");
        if (btn.dataset.value === "=") {
          try {
            display.value = eval(display.value);
          } catch {
            display.value = "Error";
          }
        } else if (btn.dataset.value === "C") {
          display.value = "";
        } else {
          display.value += btn.dataset.value;
        }
      };
    });

    auth.onAuthStateChanged(async (user) => {
      if (!user) return window.location.href = "login.html";
      const qSnap = await getDocs(collection(db, "cbt_questions"));
      let all = [];
      qSnap.forEach(doc => all.push({ id: doc.id, ...doc.data() }));
      all = all.sort(() => 0.5 - Math.random()).slice(0, 30);
      questions = all;
      showQuestion();
      startTimer(30 * 60); // 30 minutes
    });

    function showQuestion() {
      const q = questions[currentQuestion];
      qNumber.textContent = `Question ${currentQuestion + 1} of ${questions.length}`;
      questionBox.innerHTML = q.question;
      optionsBox.innerHTML = "";
      for (const opt in q.options) {
        const id = `opt${opt}`;
        const checked = userAnswers[currentQuestion] === opt ? "checked" : "";
        optionsBox.innerHTML += `
          <label><input type="radio" name="option" value="${opt}" id="${id}" ${checked}> ${opt}. ${q.options[opt]}</label><br/>
        `;
      }
    }

    nextBtn.onclick = () => {
      const selected = document.querySelector('input[name="option"]:checked');
      if (selected) userAnswers[currentQuestion] = selected.value;
      if (currentQuestion < questions.length - 1) {
        currentQuestion++;
        showQuestion();
      }
    };

    prevBtn.onclick = () => {
      const selected = document.querySelector('input[name="option"]:checked');
      if (selected) userAnswers[currentQuestion] = selected.value;
      if (currentQuestion > 0) {
        currentQuestion--;
        showQuestion();
      }
    };

    submitBtn.onclick = () => {
      if (!confirm("Are you sure you want to submit?")) return;
      clearInterval(timerInterval);
      calculateScore();
    };

    function calculateScore() {
      let score = 0;
      let missed = [];
      const result = questions.map((q, i) => {
        const correct = q.answer;
        const chosen = userAnswers[i];
        if (chosen === correct) score++;
        else missed.push({ no: i + 1, question: q.question, correct, chosen });
        return { no: i + 1, correct, chosen };
      });

      document.body.innerHTML = `
        <h2>Result</h2>
        <p><strong>Score:</strong> ${score} / ${questions.length}</p>
        <h3>Missed Questions:</h3>
        <ul>
          ${missed.map(m => `<li>Q${m.no}: Correct - ${m.correct}, Your Answer - ${m.chosen || 'None'}</li>`).join("")}
        </ul>
      `;

      // Save to Firestore
      const user = auth.currentUser;
      setDoc(doc(db, "cbt_scores", user.uid), {
        userId: user.uid,
        score,
        total: questions.length,
        timestamp: new Date()
      });

      // Update user's last CBT
      setDoc(doc(db, "users", user.uid), {
        lastCBT: new Date()
      }, { merge: true });
    }

    function startTimer(seconds) {
      let remaining = seconds;
      updateTimer();
      timerInterval = setInterval(() => {
        remaining--;
        updateTimer();
        if (remaining <= 0) {
          clearInterval(timerInterval);
          calculateScore();
        }
      }, 1000);

      function updateTimer() {
        const m = Math.floor(remaining / 60);
        const s = remaining % 60;
        timer.textContent = `Time Left: ${String(m).padStart(2, "0")}:${String(s).padStart(2, "0")}`;
      }
    }
  </script>
</body>
</html>
